__all__: list[str] = []

import cv2
import cv2.typing
import typing as _typing


# Enumerations
FEATURE_SET_COMPUTE_10: int
FEATURE_SET_COMPUTE_11: int
FEATURE_SET_COMPUTE_12: int
FEATURE_SET_COMPUTE_13: int
FEATURE_SET_COMPUTE_20: int
FEATURE_SET_COMPUTE_21: int
FEATURE_SET_COMPUTE_30: int
FEATURE_SET_COMPUTE_32: int
FEATURE_SET_COMPUTE_35: int
FEATURE_SET_COMPUTE_50: int
GLOBAL_ATOMICS: int
SHARED_ATOMICS: int
NATIVE_DOUBLE: int
WARP_SHUFFLE_FUNCTIONS: int
DYNAMIC_PARALLELISM: int
FeatureSet = int
"""One of [FEATURE_SET_COMPUTE_10, FEATURE_SET_COMPUTE_11, FEATURE_SET_COMPUTE_12, FEATURE_SET_COMPUTE_13, FEATURE_SET_COMPUTE_20, FEATURE_SET_COMPUTE_21, FEATURE_SET_COMPUTE_30, FEATURE_SET_COMPUTE_32, FEATURE_SET_COMPUTE_35, FEATURE_SET_COMPUTE_50, GLOBAL_ATOMICS, SHARED_ATOMICS, NATIVE_DOUBLE, WARP_SHUFFLE_FUNCTIONS, DYNAMIC_PARALLELISM]"""

COLOR_BayerBG2BGR_MHT: int
COLOR_BAYER_BG2BGR_MHT: int
COLOR_BayerGB2BGR_MHT: int
COLOR_BAYER_GB2BGR_MHT: int
COLOR_BayerRG2BGR_MHT: int
COLOR_BAYER_RG2BGR_MHT: int
COLOR_BayerGR2BGR_MHT: int
COLOR_BAYER_GR2BGR_MHT: int
COLOR_BayerBG2RGB_MHT: int
COLOR_BAYER_BG2RGB_MHT: int
COLOR_BayerGB2RGB_MHT: int
COLOR_BAYER_GB2RGB_MHT: int
COLOR_BayerRG2RGB_MHT: int
COLOR_BAYER_RG2RGB_MHT: int
COLOR_BayerGR2RGB_MHT: int
COLOR_BAYER_GR2RGB_MHT: int
COLOR_BayerBG2GRAY_MHT: int
COLOR_BAYER_BG2GRAY_MHT: int
COLOR_BayerGB2GRAY_MHT: int
COLOR_BAYER_GB2GRAY_MHT: int
COLOR_BayerRG2GRAY_MHT: int
COLOR_BAYER_RG2GRAY_MHT: int
COLOR_BayerGR2GRAY_MHT: int
COLOR_BAYER_GR2GRAY_MHT: int
DemosaicTypes = int
"""One of [COLOR_BayerBG2BGR_MHT, COLOR_BAYER_BG2BGR_MHT, COLOR_BayerGB2BGR_MHT, COLOR_BAYER_GB2BGR_MHT, COLOR_BayerRG2BGR_MHT, COLOR_BAYER_RG2BGR_MHT, COLOR_BayerGR2BGR_MHT, COLOR_BAYER_GR2BGR_MHT, COLOR_BayerBG2RGB_MHT, COLOR_BAYER_BG2RGB_MHT, COLOR_BayerGB2RGB_MHT, COLOR_BAYER_GB2RGB_MHT, COLOR_BayerRG2RGB_MHT, COLOR_BAYER_RG2RGB_MHT, COLOR_BayerGR2RGB_MHT, COLOR_BAYER_GR2RGB_MHT, COLOR_BayerBG2GRAY_MHT, COLOR_BAYER_BG2GRAY_MHT, COLOR_BayerGB2GRAY_MHT, COLOR_BAYER_GB2GRAY_MHT, COLOR_BayerRG2GRAY_MHT, COLOR_BAYER_RG2GRAY_MHT, COLOR_BayerGR2GRAY_MHT, COLOR_BAYER_GR2GRAY_MHT]"""

ALPHA_OVER: int
ALPHA_IN: int
ALPHA_OUT: int
ALPHA_ATOP: int
ALPHA_XOR: int
ALPHA_PLUS: int
ALPHA_OVER_PREMUL: int
ALPHA_IN_PREMUL: int
ALPHA_OUT_PREMUL: int
ALPHA_ATOP_PREMUL: int
ALPHA_XOR_PREMUL: int
ALPHA_PLUS_PREMUL: int
ALPHA_PREMUL: int
AlphaCompTypes = int
"""One of [ALPHA_OVER, ALPHA_IN, ALPHA_OUT, ALPHA_ATOP, ALPHA_XOR, ALPHA_PLUS, ALPHA_OVER_PREMUL, ALPHA_IN_PREMUL, ALPHA_OUT_PREMUL, ALPHA_ATOP_PREMUL, ALPHA_XOR_PREMUL, ALPHA_PLUS_PREMUL, ALPHA_PREMUL]"""

CCL_DEFAULT: int
CCL_BKE: int
ConnectedComponentsAlgorithmsTypes = int
"""One of [CCL_DEFAULT, CCL_BKE]"""

FIRST_ORDER_MOMENTS: int
SECOND_ORDER_MOMENTS: int
THIRD_ORDER_MOMENTS: int
MomentsOrder = int
"""One of [FIRST_ORDER_MOMENTS, SECOND_ORDER_MOMENTS, THIRD_ORDER_MOMENTS]"""


HostMem_PAGE_LOCKED: int
HOST_MEM_PAGE_LOCKED: int
HostMem_SHARED: int
HOST_MEM_SHARED: int
HostMem_WRITE_COMBINED: int
HOST_MEM_WRITE_COMBINED: int
HostMem_AllocType = int
"""One of [HostMem_PAGE_LOCKED, HOST_MEM_PAGE_LOCKED, HostMem_SHARED, HOST_MEM_SHARED, HostMem_WRITE_COMBINED, HOST_MEM_WRITE_COMBINED]"""

Event_DEFAULT: int
EVENT_DEFAULT: int
Event_BLOCKING_SYNC: int
EVENT_BLOCKING_SYNC: int
Event_DISABLE_TIMING: int
EVENT_DISABLE_TIMING: int
Event_INTERPROCESS: int
EVENT_INTERPROCESS: int
Event_CreateFlags = int
"""One of [Event_DEFAULT, EVENT_DEFAULT, Event_BLOCKING_SYNC, EVENT_BLOCKING_SYNC, Event_DISABLE_TIMING, EVENT_DISABLE_TIMING, Event_INTERPROCESS, EVENT_INTERPROCESS]"""

DeviceInfo_ComputeModeDefault: int
DEVICE_INFO_COMPUTE_MODE_DEFAULT: int
DeviceInfo_ComputeModeExclusive: int
DEVICE_INFO_COMPUTE_MODE_EXCLUSIVE: int
DeviceInfo_ComputeModeProhibited: int
DEVICE_INFO_COMPUTE_MODE_PROHIBITED: int
DeviceInfo_ComputeModeExclusiveProcess: int
DEVICE_INFO_COMPUTE_MODE_EXCLUSIVE_PROCESS: int
DeviceInfo_ComputeMode = int
"""One of [DeviceInfo_ComputeModeDefault, DEVICE_INFO_COMPUTE_MODE_DEFAULT, DeviceInfo_ComputeModeExclusive, DEVICE_INFO_COMPUTE_MODE_EXCLUSIVE, DeviceInfo_ComputeModeProhibited, DEVICE_INFO_COMPUTE_MODE_PROHIBITED, DeviceInfo_ComputeModeExclusiveProcess, DEVICE_INFO_COMPUTE_MODE_EXCLUSIVE_PROCESS]"""


# Classes
class GpuMat:
    @property
    def step(self) -> int: ...

    # Classes
    class Allocator:
        ...


    # Functions
    @_typing.overload
    def __init__(self, allocator: GpuMat.Allocator = ...) -> None: ...
    @_typing.overload
    def __init__(self, rows: int, cols: int, type: int, allocator: GpuMat.Allocator = ...) -> None: ...
    @_typing.overload
    def __init__(self, size: cv2.typing.Size, type: int, allocator: GpuMat.Allocator = ...) -> None: ...
    @_typing.overload
    def __init__(self, rows: int, cols: int, type: int, s: cv2.typing.Scalar, allocator: GpuMat.Allocator = ...) -> None: ...
    @_typing.overload
    def __init__(self, size: cv2.typing.Size, type: int, s: cv2.typing.Scalar, allocator: GpuMat.Allocator = ...) -> None: ...
    @_typing.overload
    def __init__(self, m: GpuMat) -> None: ...
    @_typing.overload
    def __init__(self, m: GpuMat, rowRange: cv2.typing.Range, colRange: cv2.typing.Range) -> None: ...
    @_typing.overload
    def __init__(self, m: GpuMat, roi: cv2.typing.Rect) -> None: ...
    @_typing.overload
    def __init__(self, arr: cv2.typing.MatLike, allocator: GpuMat.Allocator = ...) -> None: ...
    @_typing.overload
    def __init__(self, arr: GpuMat, allocator: GpuMat.Allocator = ...) -> None: ...
    @_typing.overload
    def __init__(self, arr: cv2.UMat, allocator: GpuMat.Allocator = ...) -> None: ...

    @staticmethod
    def defaultAllocator() -> GpuMat.Allocator: ...

    @staticmethod
    def setDefaultAllocator(allocator: GpuMat.Allocator) -> None: ...

    @_typing.overload
    def create(self, rows: int, cols: int, type: int) -> None: ...
    @_typing.overload
    def create(self, size: cv2.typing.Size, type: int) -> None: ...

    def release(self) -> None: ...

    def swap(self, mat: GpuMat) -> None: ...

    @_typing.overload
    def upload(self, arr: cv2.typing.MatLike) -> None: ...
    @_typing.overload
    def upload(self, arr: GpuMat) -> None: ...
    @_typing.overload
    def upload(self, arr: cv2.UMat) -> None: ...
    @_typing.overload
    def upload(self, arr: cv2.typing.MatLike, stream: Stream) -> None: ...
    @_typing.overload
    def upload(self, arr: GpuMat, stream: Stream) -> None: ...
    @_typing.overload
    def upload(self, arr: cv2.UMat, stream: Stream) -> None: ...

    @_typing.overload
    def download(self, dst: cv2.typing.MatLike | None = ...) -> cv2.typing.MatLike: ...
    @_typing.overload
    def download(self, dst: GpuMat | None = ...) -> GpuMat: ...
    @_typing.overload
    def download(self, dst: cv2.UMat | None = ...) -> cv2.UMat: ...
    @_typing.overload
    def download(self, stream: Stream, dst: cv2.typing.MatLike | None = ...) -> cv2.typing.MatLike: ...
    @_typing.overload
    def download(self, stream: Stream, dst: GpuMat | None = ...) -> GpuMat: ...
    @_typing.overload
    def download(self, stream: Stream, dst: cv2.UMat | None = ...) -> cv2.UMat: ...

    def clone(self) -> GpuMat: ...

    @_typing.overload
    def copyTo(self, dst: GpuMat | None = ...) -> GpuMat: ...
    @_typing.overload
    def copyTo(self, stream: Stream, dst: GpuMat | None = ...) -> GpuMat: ...
    @_typing.overload
    def copyTo(self, mask: GpuMat, dst: GpuMat | None = ...) -> GpuMat: ...
    @_typing.overload
    def copyTo(self, mask: GpuMat, stream: Stream, dst: GpuMat | None = ...) -> GpuMat: ...

    @_typing.overload
    def setTo(self, s: cv2.typing.Scalar) -> GpuMat: ...
    @_typing.overload
    def setTo(self, s: cv2.typing.Scalar, stream: Stream) -> GpuMat: ...
    @_typing.overload
    def setTo(self, s: cv2.typing.Scalar, mask: cv2.typing.MatLike) -> GpuMat: ...
    @_typing.overload
    def setTo(self, s: cv2.typing.Scalar, mask: GpuMat) -> GpuMat: ...
    @_typing.overload
    def setTo(self, s: cv2.typing.Scalar, mask: cv2.UMat) -> GpuMat: ...
    @_typing.overload
    def setTo(self, s: cv2.typing.Scalar, mask: cv2.typing.MatLike, stream: Stream) -> GpuMat: ...
    @_typing.overload
    def setTo(self, s: cv2.typing.Scalar, mask: GpuMat, stream: Stream) -> GpuMat: ...
    @_typing.overload
    def setTo(self, s: cv2.typing.Scalar, mask: cv2.UMat, stream: Stream) -> GpuMat: ...

    @_typing.overload
    def convertTo(self, rtype: int, stream: Stream, dst: GpuMat | None = ...) -> GpuMat: ...
    @_typing.overload
    def convertTo(self, rtype: int, dst: GpuMat | None = ..., alpha: float = ..., beta: float = ...) -> GpuMat: ...
    @_typing.overload
    def convertTo(self, rtype: int, alpha: float, beta: float, stream: Stream, dst: GpuMat | None = ...) -> GpuMat: ...

    def assignTo(self, m: GpuMat, type: int = ...) -> None: ...

    def row(self, y: int) -> GpuMat: ...

    def col(self, x: int) -> GpuMat: ...

    @_typing.overload
    def rowRange(self, startrow: int, endrow: int) -> GpuMat: ...
    @_typing.overload
    def rowRange(self, r: cv2.typing.Range) -> GpuMat: ...

    @_typing.overload
    def colRange(self, startcol: int, endcol: int) -> GpuMat: ...
    @_typing.overload
    def colRange(self, r: cv2.typing.Range) -> GpuMat: ...

    def reshape(self, cn: int, rows: int = ...) -> GpuMat: ...

    def locateROI(self, wholeSize: cv2.typing.Size, ofs: cv2.typing.Point) -> None: ...

    def adjustROI(self, dtop: int, dbottom: int, dleft: int, dright: int) -> GpuMat: ...

    def isContinuous(self) -> bool: ...

    def elemSize(self) -> int: ...

    def elemSize1(self) -> int: ...

    def type(self) -> int: ...

    def depth(self) -> int: ...

    def channels(self) -> int: ...

    def step1(self) -> int: ...

    def size(self) -> cv2.typing.Size: ...

    def empty(self) -> bool: ...

    def cudaPtr(self) -> cv2.typing.IntPointer: ...

    def updateContinuityFlag(self) -> None: ...


class GpuData:
    ...

class GpuMatND:
    ...

class BufferPool:
    # Functions
    def __init__(self, stream: Stream) -> None: ...

    @_typing.overload
    def getBuffer(self, rows: int, cols: int, type: int) -> GpuMat: ...
    @_typing.overload
    def getBuffer(self, size: cv2.typing.Size, type: int) -> GpuMat: ...

    def getAllocator(self) -> GpuMat.Allocator: ...


class HostMem:
    @property
    def step(self) -> int: ...

    # Functions
    @_typing.overload
    def __init__(self, alloc_type: HostMem_AllocType = ...) -> None: ...
    @_typing.overload
    def __init__(self, rows: int, cols: int, type: int, alloc_type: HostMem_AllocType = ...) -> None: ...
    @_typing.overload
    def __init__(self, size: cv2.typing.Size, type: int, alloc_type: HostMem_AllocType = ...) -> None: ...
    @_typing.overload
    def __init__(self, arr: cv2.typing.MatLike, alloc_type: HostMem_AllocType = ...) -> None: ...
    @_typing.overload
    def __init__(self, arr: GpuMat, alloc_type: HostMem_AllocType = ...) -> None: ...
    @_typing.overload
    def __init__(self, arr: cv2.UMat, alloc_type: HostMem_AllocType = ...) -> None: ...

    def swap(self, b: HostMem) -> None: ...

    def clone(self) -> HostMem: ...

    def create(self, rows: int, cols: int, type: int) -> None: ...

    def reshape(self, cn: int, rows: int = ...) -> HostMem: ...

    def createMatHeader(self) -> cv2.typing.MatLike: ...

    def isContinuous(self) -> bool: ...

    def elemSize(self) -> int: ...

    def elemSize1(self) -> int: ...

    def type(self) -> int: ...

    def depth(self) -> int: ...

    def channels(self) -> int: ...

    def step1(self) -> int: ...

    def size(self) -> cv2.typing.Size: ...

    def empty(self) -> bool: ...


class Stream:
    # Functions
    @_typing.overload
    def __init__(self) -> None: ...
    @_typing.overload
    def __init__(self, allocator: GpuMat.Allocator) -> None: ...
    @_typing.overload
    def __init__(self, cudaFlags: int) -> None: ...

    def queryIfComplete(self) -> bool: ...

    def waitForCompletion(self) -> None: ...

    def waitEvent(self, event: Event) -> None: ...

    @classmethod
    def Null(cls) -> Stream: ...

    def cudaPtr(self) -> cv2.typing.IntPointer: ...


class Event:
    # Functions
    def __init__(self, flags: Event_CreateFlags = ...) -> None: ...

    def record(self, stream: Stream = ...) -> None: ...

    def queryIfComplete(self) -> bool: ...

    def waitForCompletion(self) -> None: ...

    @staticmethod
    def elapsedTime(start: Event, end: Event) -> float: ...


class TargetArchs:
    # Functions
    @staticmethod
    def has(major: int, minor: int) -> bool: ...

    @staticmethod
    def hasPtx(major: int, minor: int) -> bool: ...

    @staticmethod
    def hasBin(major: int, minor: int) -> bool: ...

    @staticmethod
    def hasEqualOrLessPtx(major: int, minor: int) -> bool: ...

    @staticmethod
    def hasEqualOrGreater(major: int, minor: int) -> bool: ...

    @staticmethod
    def hasEqualOrGreaterPtx(major: int, minor: int) -> bool: ...

    @staticmethod
    def hasEqualOrGreaterBin(major: int, minor: int) -> bool: ...


class DeviceInfo:
    # Functions
    @_typing.overload
    def __init__(self) -> None: ...
    @_typing.overload
    def __init__(self, device_id: int) -> None: ...

    def deviceID(self) -> int: ...

    def totalGlobalMem(self) -> int: ...

    def sharedMemPerBlock(self) -> int: ...

    def regsPerBlock(self) -> int: ...

    def warpSize(self) -> int: ...

    def memPitch(self) -> int: ...

    def maxThreadsPerBlock(self) -> int: ...

    def maxThreadsDim(self) -> cv2.typing.Vec3i: ...

    def maxGridSize(self) -> cv2.typing.Vec3i: ...

    def clockRate(self) -> int: ...

    def totalConstMem(self) -> int: ...

    def majorVersion(self) -> int: ...

    def minorVersion(self) -> int: ...

    def textureAlignment(self) -> int: ...

    def texturePitchAlignment(self) -> int: ...

    def multiProcessorCount(self) -> int: ...

    def kernelExecTimeoutEnabled(self) -> bool: ...

    def integrated(self) -> bool: ...

    def canMapHostMemory(self) -> bool: ...

    def computeMode(self) -> DeviceInfo_ComputeMode: ...

    def maxTexture1D(self) -> int: ...

    def maxTexture1DMipmap(self) -> int: ...

    def maxTexture1DLinear(self) -> int: ...

    def maxTexture2D(self) -> cv2.typing.Vec2i: ...

    def maxTexture2DMipmap(self) -> cv2.typing.Vec2i: ...

    def maxTexture2DLinear(self) -> cv2.typing.Vec3i: ...

    def maxTexture2DGather(self) -> cv2.typing.Vec2i: ...

    def maxTexture3D(self) -> cv2.typing.Vec3i: ...

    def maxTextureCubemap(self) -> int: ...

    def maxTexture1DLayered(self) -> cv2.typing.Vec2i: ...

    def maxTexture2DLayered(self) -> cv2.typing.Vec3i: ...

    def maxTextureCubemapLayered(self) -> cv2.typing.Vec2i: ...

    def maxSurface1D(self) -> int: ...

    def maxSurface2D(self) -> cv2.typing.Vec2i: ...

    def maxSurface3D(self) -> cv2.typing.Vec3i: ...

    def maxSurface1DLayered(self) -> cv2.typing.Vec2i: ...

    def maxSurface2DLayered(self) -> cv2.typing.Vec3i: ...

    def maxSurfaceCubemap(self) -> int: ...

    def maxSurfaceCubemapLayered(self) -> cv2.typing.Vec2i: ...

    def surfaceAlignment(self) -> int: ...

    def concurrentKernels(self) -> bool: ...

    def ECCEnabled(self) -> bool: ...

    def pciBusID(self) -> int: ...

    def pciDeviceID(self) -> int: ...

    def pciDomainID(self) -> int: ...

    def tccDriver(self) -> bool: ...

    def asyncEngineCount(self) -> int: ...

    def unifiedAddressing(self) -> bool: ...

    def memoryClockRate(self) -> int: ...

    def memoryBusWidth(self) -> int: ...

    def l2CacheSize(self) -> int: ...

    def maxThreadsPerMultiProcessor(self) -> int: ...

    def queryMemory(self, totalMemory: int, freeMemory: int) -> None: ...

    def freeMemory(self) -> int: ...

    def totalMemory(self) -> int: ...

    def isCompatible(self) -> bool: ...


class CLAHE(cv2.CLAHE):
    # Functions
    @_typing.overload
    def apply(self, src: cv2.typing.MatLike, stream: Stream, dst: cv2.typing.MatLike | None = ...) -> cv2.typing.MatLike: ...
    @_typing.overload
    def apply(self, src: GpuMat, stream: Stream, dst: GpuMat | None = ...) -> GpuMat: ...
    @_typing.overload
    def apply(self, src: cv2.UMat, stream: Stream, dst: cv2.UMat | None = ...) -> cv2.UMat: ...


class CannyEdgeDetector(cv2.Algorithm):
    # Functions
    @_typing.overload
    def detect(self, image: cv2.typing.MatLike, edges: cv2.typing.MatLike | None = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
    @_typing.overload
    def detect(self, image: GpuMat, edges: GpuMat | None = ..., stream: Stream = ...) -> GpuMat: ...
    @_typing.overload
    def detect(self, image: cv2.UMat, edges: cv2.UMat | None = ..., stream: Stream = ...) -> cv2.UMat: ...
    @_typing.overload
    def detect(self, dx: cv2.typing.MatLike, dy: cv2.typing.MatLike, edges: cv2.typing.MatLike | None = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
    @_typing.overload
    def detect(self, dx: GpuMat, dy: GpuMat, edges: GpuMat | None = ..., stream: Stream = ...) -> GpuMat: ...
    @_typing.overload
    def detect(self, dx: cv2.UMat, dy: cv2.UMat, edges: cv2.UMat | None = ..., stream: Stream = ...) -> cv2.UMat: ...

    def setLowThreshold(self, low_thresh: float) -> None: ...

    def getLowThreshold(self) -> float: ...

    def setHighThreshold(self, high_thresh: float) -> None: ...

    def getHighThreshold(self) -> float: ...

    def setAppertureSize(self, apperture_size: int) -> None: ...

    def getAppertureSize(self) -> int: ...

    def setL2Gradient(self, L2gradient: bool) -> None: ...

    def getL2Gradient(self) -> bool: ...


class HoughLinesDetector(cv2.Algorithm):
    # Functions
    @_typing.overload
    def detect(self, src: cv2.typing.MatLike, lines: cv2.typing.MatLike | None = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
    @_typing.overload
    def detect(self, src: GpuMat, lines: GpuMat | None = ..., stream: Stream = ...) -> GpuMat: ...
    @_typing.overload
    def detect(self, src: cv2.UMat, lines: cv2.UMat | None = ..., stream: Stream = ...) -> cv2.UMat: ...

    @_typing.overload
    def downloadResults(self, d_lines: cv2.typing.MatLike, h_lines: cv2.typing.MatLike | None = ..., h_votes: cv2.typing.MatLike | None = ..., stream: Stream = ...) -> tuple[cv2.typing.MatLike, cv2.typing.MatLike]: ...
    @_typing.overload
    def downloadResults(self, d_lines: GpuMat, h_lines: GpuMat | None = ..., h_votes: GpuMat | None = ..., stream: Stream = ...) -> tuple[GpuMat, GpuMat]: ...
    @_typing.overload
    def downloadResults(self, d_lines: cv2.UMat, h_lines: cv2.UMat | None = ..., h_votes: cv2.UMat | None = ..., stream: Stream = ...) -> tuple[cv2.UMat, cv2.UMat]: ...

    def setRho(self, rho: float) -> None: ...

    def getRho(self) -> float: ...

    def setTheta(self, theta: float) -> None: ...

    def getTheta(self) -> float: ...

    def setThreshold(self, threshold: int) -> None: ...

    def getThreshold(self) -> int: ...

    def setDoSort(self, doSort: bool) -> None: ...

    def getDoSort(self) -> bool: ...

    def setMaxLines(self, maxLines: int) -> None: ...

    def getMaxLines(self) -> int: ...


class HoughSegmentDetector(cv2.Algorithm):
    # Functions
    @_typing.overload
    def detect(self, src: cv2.typing.MatLike, lines: cv2.typing.MatLike | None = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
    @_typing.overload
    def detect(self, src: GpuMat, lines: GpuMat | None = ..., stream: Stream = ...) -> GpuMat: ...
    @_typing.overload
    def detect(self, src: cv2.UMat, lines: cv2.UMat | None = ..., stream: Stream = ...) -> cv2.UMat: ...

    def setRho(self, rho: float) -> None: ...

    def getRho(self) -> float: ...

    def setTheta(self, theta: float) -> None: ...

    def getTheta(self) -> float: ...

    def setMinLineLength(self, minLineLength: int) -> None: ...

    def getMinLineLength(self) -> int: ...

    def setMaxLineGap(self, maxLineGap: int) -> None: ...

    def getMaxLineGap(self) -> int: ...

    def setMaxLines(self, maxLines: int) -> None: ...

    def getMaxLines(self) -> int: ...

    def setThreshold(self, threshold: int) -> None: ...

    def getThreshold(self) -> int: ...


class HoughCirclesDetector(cv2.Algorithm):
    # Functions
    @_typing.overload
    def detect(self, src: cv2.typing.MatLike, circles: cv2.typing.MatLike | None = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
    @_typing.overload
    def detect(self, src: GpuMat, circles: GpuMat | None = ..., stream: Stream = ...) -> GpuMat: ...
    @_typing.overload
    def detect(self, src: cv2.UMat, circles: cv2.UMat | None = ..., stream: Stream = ...) -> cv2.UMat: ...

    def setDp(self, dp: float) -> None: ...

    def getDp(self) -> float: ...

    def setMinDist(self, minDist: float) -> None: ...

    def getMinDist(self) -> float: ...

    def setCannyThreshold(self, cannyThreshold: int) -> None: ...

    def getCannyThreshold(self) -> int: ...

    def setVotesThreshold(self, votesThreshold: int) -> None: ...

    def getVotesThreshold(self) -> int: ...

    def setMinRadius(self, minRadius: int) -> None: ...

    def getMinRadius(self) -> int: ...

    def setMaxRadius(self, maxRadius: int) -> None: ...

    def getMaxRadius(self) -> int: ...

    def setMaxCircles(self, maxCircles: int) -> None: ...

    def getMaxCircles(self) -> int: ...


class CornernessCriteria(cv2.Algorithm):
    # Functions
    @_typing.overload
    def compute(self, src: cv2.typing.MatLike, dst: cv2.typing.MatLike | None = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
    @_typing.overload
    def compute(self, src: GpuMat, dst: GpuMat | None = ..., stream: Stream = ...) -> GpuMat: ...
    @_typing.overload
    def compute(self, src: cv2.UMat, dst: cv2.UMat | None = ..., stream: Stream = ...) -> cv2.UMat: ...


class CornersDetector(cv2.Algorithm):
    # Functions
    @_typing.overload
    def detect(self, image: cv2.typing.MatLike, corners: cv2.typing.MatLike | None = ..., mask: cv2.typing.MatLike | None = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
    @_typing.overload
    def detect(self, image: GpuMat, corners: GpuMat | None = ..., mask: GpuMat | None = ..., stream: Stream = ...) -> GpuMat: ...
    @_typing.overload
    def detect(self, image: cv2.UMat, corners: cv2.UMat | None = ..., mask: cv2.UMat | None = ..., stream: Stream = ...) -> cv2.UMat: ...

    def setMaxCorners(self, maxCorners: int) -> None: ...

    def setMinDistance(self, minDistance: float) -> None: ...


class TemplateMatching(cv2.Algorithm):
    # Functions
    @_typing.overload
    def match(self, image: cv2.typing.MatLike, templ: cv2.typing.MatLike, result: cv2.typing.MatLike | None = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
    @_typing.overload
    def match(self, image: GpuMat, templ: GpuMat, result: GpuMat | None = ..., stream: Stream = ...) -> GpuMat: ...
    @_typing.overload
    def match(self, image: cv2.UMat, templ: cv2.UMat, result: cv2.UMat | None = ..., stream: Stream = ...) -> cv2.UMat: ...



# Functions
@_typing.overload
def alphaComp(img1: cv2.typing.MatLike, img2: cv2.typing.MatLike, alpha_op: int, dst: cv2.typing.MatLike | None = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
@_typing.overload
def alphaComp(img1: GpuMat, img2: GpuMat, alpha_op: int, dst: GpuMat | None = ..., stream: Stream = ...) -> GpuMat: ...
@_typing.overload
def alphaComp(img1: cv2.UMat, img2: cv2.UMat, alpha_op: int, dst: cv2.UMat | None = ..., stream: Stream = ...) -> cv2.UMat: ...

@_typing.overload
def bilateralFilter(src: cv2.typing.MatLike, kernel_size: int, sigma_color: float, sigma_spatial: float, dst: cv2.typing.MatLike | None = ..., borderMode: int = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
@_typing.overload
def bilateralFilter(src: GpuMat, kernel_size: int, sigma_color: float, sigma_spatial: float, dst: GpuMat | None = ..., borderMode: int = ..., stream: Stream = ...) -> GpuMat: ...
@_typing.overload
def bilateralFilter(src: cv2.UMat, kernel_size: int, sigma_color: float, sigma_spatial: float, dst: cv2.UMat | None = ..., borderMode: int = ..., stream: Stream = ...) -> cv2.UMat: ...

@_typing.overload
def blendLinear(img1: cv2.typing.MatLike, img2: cv2.typing.MatLike, weights1: cv2.typing.MatLike, weights2: cv2.typing.MatLike, result: cv2.typing.MatLike | None = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
@_typing.overload
def blendLinear(img1: GpuMat, img2: GpuMat, weights1: GpuMat, weights2: GpuMat, result: GpuMat | None = ..., stream: Stream = ...) -> GpuMat: ...
@_typing.overload
def blendLinear(img1: cv2.UMat, img2: cv2.UMat, weights1: cv2.UMat, weights2: cv2.UMat, result: cv2.UMat | None = ..., stream: Stream = ...) -> cv2.UMat: ...

@_typing.overload
def calcHist(src: cv2.typing.MatLike, hist: cv2.typing.MatLike | None = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
@_typing.overload
def calcHist(src: GpuMat, hist: GpuMat | None = ..., stream: Stream = ...) -> GpuMat: ...
@_typing.overload
def calcHist(src: cv2.UMat, hist: cv2.UMat | None = ..., stream: Stream = ...) -> cv2.UMat: ...
@_typing.overload
def calcHist(src: cv2.typing.MatLike, mask: cv2.typing.MatLike, hist: cv2.typing.MatLike | None = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
@_typing.overload
def calcHist(src: GpuMat, mask: GpuMat, hist: GpuMat | None = ..., stream: Stream = ...) -> GpuMat: ...
@_typing.overload
def calcHist(src: cv2.UMat, mask: cv2.UMat, hist: cv2.UMat | None = ..., stream: Stream = ...) -> cv2.UMat: ...

@_typing.overload
def connectedComponents(image: cv2.typing.MatLike, labels: cv2.typing.MatLike | None = ..., connectivity: int = ..., ltype: int = ...) -> cv2.typing.MatLike: ...
@_typing.overload
def connectedComponents(image: GpuMat, labels: GpuMat | None = ..., connectivity: int = ..., ltype: int = ...) -> GpuMat: ...
@_typing.overload
def connectedComponents(image: cv2.UMat, labels: cv2.UMat | None = ..., connectivity: int = ..., ltype: int = ...) -> cv2.UMat: ...

@_typing.overload
def connectedComponentsWithAlgorithm(image: cv2.typing.MatLike, connectivity: int, ltype: int, ccltype: ConnectedComponentsAlgorithmsTypes, labels: cv2.typing.MatLike | None = ...) -> cv2.typing.MatLike: ...
@_typing.overload
def connectedComponentsWithAlgorithm(image: GpuMat, connectivity: int, ltype: int, ccltype: ConnectedComponentsAlgorithmsTypes, labels: GpuMat | None = ...) -> GpuMat: ...
@_typing.overload
def connectedComponentsWithAlgorithm(image: cv2.UMat, connectivity: int, ltype: int, ccltype: ConnectedComponentsAlgorithmsTypes, labels: cv2.UMat | None = ...) -> cv2.UMat: ...

def convertSpatialMoments(spatialMoments: cv2.typing.MatLike, order: MomentsOrder, momentsType: int) -> cv2.typing.Moments: ...

def createCLAHE(clipLimit: float = ..., tileGridSize: cv2.typing.Size = ...) -> CLAHE: ...

def createCannyEdgeDetector(low_thresh: float, high_thresh: float, apperture_size: int = ..., L2gradient: bool = ...) -> CannyEdgeDetector: ...

@_typing.overload
def createContinuous(rows: int, cols: int, type: int, arr: cv2.typing.MatLike | None = ...) -> cv2.typing.MatLike: ...
@_typing.overload
def createContinuous(rows: int, cols: int, type: int, arr: GpuMat | None = ...) -> GpuMat: ...
@_typing.overload
def createContinuous(rows: int, cols: int, type: int, arr: cv2.UMat | None = ...) -> cv2.UMat: ...

def createGeneralizedHoughBallard() -> cv2.GeneralizedHoughBallard: ...

def createGeneralizedHoughGuil() -> cv2.GeneralizedHoughGuil: ...

def createGoodFeaturesToTrackDetector(srcType: int, maxCorners: int = ..., qualityLevel: float = ..., minDistance: float = ..., blockSize: int = ..., useHarrisDetector: bool = ..., harrisK: float = ...) -> CornersDetector: ...

@_typing.overload
def createGpuMatFromCudaMemory(rows: int, cols: int, type: int, cudaMemoryAddress: int, step: int = ...) -> GpuMat: ...
@_typing.overload
def createGpuMatFromCudaMemory(size: cv2.typing.Size, type: int, cudaMemoryAddress: int, step: int = ...) -> GpuMat: ...

def createHarrisCorner(srcType: int, blockSize: int, ksize: int, k: float, borderType: int = ...) -> CornernessCriteria: ...

def createHoughCirclesDetector(dp: float, minDist: float, cannyThreshold: int, votesThreshold: int, minRadius: int, maxRadius: int, maxCircles: int = ...) -> HoughCirclesDetector: ...

def createHoughLinesDetector(rho: float, theta: float, threshold: int, doSort: bool = ..., maxLines: int = ...) -> HoughLinesDetector: ...

def createHoughSegmentDetector(rho: float, theta: float, minLineLength: int, maxLineGap: int, maxLines: int = ..., threshold: int = ...) -> HoughSegmentDetector: ...

def createMinEigenValCorner(srcType: int, blockSize: int, ksize: int, borderType: int = ...) -> CornernessCriteria: ...

def createTemplateMatching(srcType: int, method: int, user_block_size: cv2.typing.Size = ...) -> TemplateMatching: ...

@_typing.overload
def cvtColor(src: cv2.typing.MatLike, code: int, dst: cv2.typing.MatLike | None = ..., dcn: int = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
@_typing.overload
def cvtColor(src: GpuMat, code: int, dst: GpuMat | None = ..., dcn: int = ..., stream: Stream = ...) -> GpuMat: ...
@_typing.overload
def cvtColor(src: cv2.UMat, code: int, dst: cv2.UMat | None = ..., dcn: int = ..., stream: Stream = ...) -> cv2.UMat: ...

@_typing.overload
def demosaicing(src: cv2.typing.MatLike, code: int, dst: cv2.typing.MatLike | None = ..., dcn: int = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
@_typing.overload
def demosaicing(src: GpuMat, code: int, dst: GpuMat | None = ..., dcn: int = ..., stream: Stream = ...) -> GpuMat: ...
@_typing.overload
def demosaicing(src: cv2.UMat, code: int, dst: cv2.UMat | None = ..., dcn: int = ..., stream: Stream = ...) -> cv2.UMat: ...

@_typing.overload
def ensureSizeIsEnough(rows: int, cols: int, type: int, arr: cv2.typing.MatLike | None = ...) -> cv2.typing.MatLike: ...
@_typing.overload
def ensureSizeIsEnough(rows: int, cols: int, type: int, arr: GpuMat | None = ...) -> GpuMat: ...
@_typing.overload
def ensureSizeIsEnough(rows: int, cols: int, type: int, arr: cv2.UMat | None = ...) -> cv2.UMat: ...

@_typing.overload
def equalizeHist(src: cv2.typing.MatLike, dst: cv2.typing.MatLike | None = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
@_typing.overload
def equalizeHist(src: GpuMat, dst: GpuMat | None = ..., stream: Stream = ...) -> GpuMat: ...
@_typing.overload
def equalizeHist(src: cv2.UMat, dst: cv2.UMat | None = ..., stream: Stream = ...) -> cv2.UMat: ...

@_typing.overload
def evenLevels(nLevels: int, lowerLevel: int, upperLevel: int, levels: cv2.typing.MatLike | None = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
@_typing.overload
def evenLevels(nLevels: int, lowerLevel: int, upperLevel: int, levels: GpuMat | None = ..., stream: Stream = ...) -> GpuMat: ...
@_typing.overload
def evenLevels(nLevels: int, lowerLevel: int, upperLevel: int, levels: cv2.UMat | None = ..., stream: Stream = ...) -> cv2.UMat: ...

def fastNlMeansDenoising(src: GpuMat, h: float, dst: GpuMat | None = ..., search_window: int = ..., block_size: int = ..., stream: Stream = ...) -> GpuMat: ...

def fastNlMeansDenoisingColored(src: GpuMat, h_luminance: float, photo_render: float, dst: GpuMat | None = ..., search_window: int = ..., block_size: int = ..., stream: Stream = ...) -> GpuMat: ...

@_typing.overload
def gammaCorrection(src: cv2.typing.MatLike, dst: cv2.typing.MatLike | None = ..., forward: bool = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
@_typing.overload
def gammaCorrection(src: GpuMat, dst: GpuMat | None = ..., forward: bool = ..., stream: Stream = ...) -> GpuMat: ...
@_typing.overload
def gammaCorrection(src: cv2.UMat, dst: cv2.UMat | None = ..., forward: bool = ..., stream: Stream = ...) -> cv2.UMat: ...

def getCudaEnabledDeviceCount() -> int: ...

def getDevice() -> int: ...

@_typing.overload
def histEven(src: cv2.typing.MatLike, histSize: int, lowerLevel: int, upperLevel: int, hist: cv2.typing.MatLike | None = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
@_typing.overload
def histEven(src: GpuMat, histSize: int, lowerLevel: int, upperLevel: int, hist: GpuMat | None = ..., stream: Stream = ...) -> GpuMat: ...
@_typing.overload
def histEven(src: cv2.UMat, histSize: int, lowerLevel: int, upperLevel: int, hist: cv2.UMat | None = ..., stream: Stream = ...) -> cv2.UMat: ...
@_typing.overload
def histEven(src: cv2.typing.MatLike, hist: GpuMat, histSize: int, lowerLevel: int, upperLevel: int, stream: Stream = ...) -> None: ...
@_typing.overload
def histEven(src: GpuMat, hist: GpuMat, histSize: int, lowerLevel: int, upperLevel: int, stream: Stream = ...) -> None: ...
@_typing.overload
def histEven(src: cv2.UMat, hist: GpuMat, histSize: int, lowerLevel: int, upperLevel: int, stream: Stream = ...) -> None: ...

@_typing.overload
def histRange(src: cv2.typing.MatLike, levels: cv2.typing.MatLike, hist: cv2.typing.MatLike | None = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
@_typing.overload
def histRange(src: GpuMat, levels: GpuMat, hist: GpuMat | None = ..., stream: Stream = ...) -> GpuMat: ...
@_typing.overload
def histRange(src: cv2.UMat, levels: cv2.UMat, hist: cv2.UMat | None = ..., stream: Stream = ...) -> cv2.UMat: ...
@_typing.overload
def histRange(src: cv2.typing.MatLike, hist: GpuMat, levels: GpuMat, stream: Stream = ...) -> None: ...
@_typing.overload
def histRange(src: GpuMat, hist: GpuMat, levels: GpuMat, stream: Stream = ...) -> None: ...
@_typing.overload
def histRange(src: cv2.UMat, hist: GpuMat, levels: GpuMat, stream: Stream = ...) -> None: ...

@_typing.overload
def meanShiftFiltering(src: cv2.typing.MatLike, sp: int, sr: int, dst: cv2.typing.MatLike | None = ..., criteria: cv2.typing.TermCriteria = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
@_typing.overload
def meanShiftFiltering(src: GpuMat, sp: int, sr: int, dst: GpuMat | None = ..., criteria: cv2.typing.TermCriteria = ..., stream: Stream = ...) -> GpuMat: ...
@_typing.overload
def meanShiftFiltering(src: cv2.UMat, sp: int, sr: int, dst: cv2.UMat | None = ..., criteria: cv2.typing.TermCriteria = ..., stream: Stream = ...) -> cv2.UMat: ...

@_typing.overload
def meanShiftProc(src: cv2.typing.MatLike, sp: int, sr: int, dstr: cv2.typing.MatLike | None = ..., dstsp: cv2.typing.MatLike | None = ..., criteria: cv2.typing.TermCriteria = ..., stream: Stream = ...) -> tuple[cv2.typing.MatLike, cv2.typing.MatLike]: ...
@_typing.overload
def meanShiftProc(src: GpuMat, sp: int, sr: int, dstr: GpuMat | None = ..., dstsp: GpuMat | None = ..., criteria: cv2.typing.TermCriteria = ..., stream: Stream = ...) -> tuple[GpuMat, GpuMat]: ...
@_typing.overload
def meanShiftProc(src: cv2.UMat, sp: int, sr: int, dstr: cv2.UMat | None = ..., dstsp: cv2.UMat | None = ..., criteria: cv2.typing.TermCriteria = ..., stream: Stream = ...) -> tuple[cv2.UMat, cv2.UMat]: ...

@_typing.overload
def meanShiftSegmentation(src: cv2.typing.MatLike, sp: int, sr: int, minsize: int, dst: cv2.typing.MatLike | None = ..., criteria: cv2.typing.TermCriteria = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
@_typing.overload
def meanShiftSegmentation(src: GpuMat, sp: int, sr: int, minsize: int, dst: GpuMat | None = ..., criteria: cv2.typing.TermCriteria = ..., stream: Stream = ...) -> GpuMat: ...
@_typing.overload
def meanShiftSegmentation(src: cv2.UMat, sp: int, sr: int, minsize: int, dst: cv2.UMat | None = ..., criteria: cv2.typing.TermCriteria = ..., stream: Stream = ...) -> cv2.UMat: ...

@_typing.overload
def moments(src: cv2.typing.MatLike, binaryImage: bool = ..., order: MomentsOrder = ..., momentsType: int = ...) -> cv2.typing.Moments: ...
@_typing.overload
def moments(src: GpuMat, binaryImage: bool = ..., order: MomentsOrder = ..., momentsType: int = ...) -> cv2.typing.Moments: ...
@_typing.overload
def moments(src: cv2.UMat, binaryImage: bool = ..., order: MomentsOrder = ..., momentsType: int = ...) -> cv2.typing.Moments: ...

def nonLocalMeans(src: GpuMat, h: float, dst: GpuMat | None = ..., search_window: int = ..., block_size: int = ..., borderMode: int = ..., stream: Stream = ...) -> GpuMat: ...

def numMoments(order: MomentsOrder) -> int: ...

def printCudaDeviceInfo(device: int) -> None: ...

def printShortCudaDeviceInfo(device: int) -> None: ...

def registerPageLocked(m: cv2.typing.MatLike) -> None: ...

def resetDevice() -> None: ...

def setBufferPoolConfig(deviceId: int, stackSize: int, stackCount: int) -> None: ...

def setBufferPoolUsage(on: bool) -> None: ...

def setDevice(device: int) -> None: ...

@_typing.overload
def spatialMoments(src: cv2.typing.MatLike, moments: cv2.typing.MatLike | None = ..., binaryImage: bool = ..., order: MomentsOrder = ..., momentsType: int = ..., stream: Stream = ...) -> cv2.typing.MatLike: ...
@_typing.overload
def spatialMoments(src: GpuMat, moments: GpuMat | None = ..., binaryImage: bool = ..., order: MomentsOrder = ..., momentsType: int = ..., stream: Stream = ...) -> GpuMat: ...
@_typing.overload
def spatialMoments(src: cv2.UMat, moments: cv2.UMat | None = ..., binaryImage: bool = ..., order: MomentsOrder = ..., momentsType: int = ..., stream: Stream = ...) -> cv2.UMat: ...

def unregisterPageLocked(m: cv2.typing.MatLike) -> None: ...

def wrapStream(cudaStreamMemoryAddress: int) -> Stream: ...


